---
title: "Reproducible Data Analysis Day 4: Data loading and tidying with tidyverse"
format: gfm
---

### Learning Objectives

By the end of this class, you should

- Understand what packages are and how to use them
- Be able to load data into R
- Be able to use the six main data frame manipulation functions (and pipes) in  `dplyr`

## What is data wrangling?

Manipulation of data frames means many things to many researchers: we often
select certain observations (rows) or variables (columns), we often group the
data by a certain variable(s), or we even calculate summary statistics. This is
collectively referred to as "Data Wrangling" (to "wrangle" means to organize
something unruly, like livestock).

## Create the project

As before, create a new project to practice today's code in the
`data-analysis-course` folder on your Desktop. Call it `gapminder-analysis`,
since we will be analyzing a dataset called "gapminder" (we will continue to use
this dataset for the remainder of the course). Also, create a folder called
`data_raw` inside the project.

Today we will be loading data from an external file (`gapminder.csv`). Download
the file from this link, and put it in the `data_raw` folder in your project:
<https://www.dropbox.com/s/fdirlsnxlzy53qq/gapminder.csv?dl=0>

## Installing and loading packages

For this lesson, we will use functions that are not included in R by default
("Base R"). **Packages** are collections of code that expand R's functionality.
There are nearly 200,000 packages available on CRAN, the biggest repository of R
packages.

To install a new package, use the `install.packages()` function, specifying the
name of the package in quotation marks. Here, we will install a package called
`tidyverse`:

```{r}
#| eval: false
install.packages("tidyverse")
```

Actually the "tidyverse" is a **collection** of R packages designed for data
science, including `readr`(for loading data), `dplyr` (for data manipulation),
`ggplot` (for plotting), and others. These packages are specifically designed to
work harmoniously together. Some of these packages will be covered along this
course, but you can find more complete information here:
[https://www.tidyverse.org/](https://www.tidyverse.org/).

You only have to install the package once, which downloads it to your computer.
But each time you want to use the package in an R session, you need to load it
with the `library()` function, like this:

```{r}
library(tidyverse)
```

Notice that since `tidyverse` contains multiple packages, it loads each of those and prints a message for each.

Somewhat confusingly, you **don't** need to put the name of the pacakge
quotation marks when using `library()`, but you **do** when using
`install.packages()`. Also, you can only load one package at a time using
`library()`, so if you needed to load multiple packages, you would need to do it
like this (this example shows two packages included in `tidyverse`):

```{r}
#| eval: false
library(dplyr)
library(ggplot)
```

## Loading data

We can use the `read_csv()` function from the `readr` package included in
`tidyverse` to load the data into R.

```{r}
gapminder <- read_csv("data_raw/gapminder.csv")
```

R loads the data as a **dataframe**, also called a "tibble". But what is a
dataframe?

## What are dataframes?

When we loaded the data into R, it got stored as an object of class **tibble**,
which is a special kind of dataframe (the difference is not important for our
purposes, but you can learn more about tibbles
[here](https://tibble.tidyverse.org/)). Dataframes are the *de facto* data
structure for most tabular data, and what we use for statistics and plotting.
Data frames can be created by hand, but most commonly they are generated by
functions like `read_csv()`; in other words, when importing spreadsheets from
your hard drive or the web.

A dataframe is the representation of data in the format of a table where the
columns are vectors that all have the same length. Because columns are vectors,
each column must contain a single type of data (e.g., characters, integers,
factors). For example, here is a figure depicting a dataframe comprising a
numeric, a character, and a logical vector.

![](images/dataframe.png)

## Inspect the data

You can see the contents of a dataframe by typing its name in the R console:

```{r}
gapminder
```

R gives you some useful summary information: the number of rows (1,704) and
columns (6) and the type of each column (`chr` is character, `dbl` is numeric).

## About the "gapminder" dataset

This dataset includes economic statistics from various countries over time, from
<https://gapminder.org>.

The meaning of some columns is obvious (`country`, `continent`, `year`), but not
others. Here is a short explanation of those:

- `pop`: Population
- `lifeExp`: Life expectancy (寿命)
- `gdpPercap`: GDP per capita (一人当たりの国内総生産)

## Sort data with `arrange()`

First provide the **name of the dataframe**, then the **column** to sort by:

```{r}
arrange(gapminder, lifeExp)
```

The default setting is to sort from **small** to **large**. To sort in the
reverse (**descending**) direction, use `desc()`:

```{r}
arrange(gapminder, desc(lifeExp))
```

You can sort on **multiple** columns. Ties will be sorted by the next column:

```{r}
arrange(gapminder, continent, lifeExp)
```

## Narrow down columns with `select()`

First provide the **name of the dataframe**, then the **columns** to select:

```{r}
select(gapminder, year, country, gdpPercap)
```

## Saving your output

Notice that although we have used several functions, `gapminder` is still the
same:

```{r}
gapminder
```

This is because we have not **saved** any of the output. To do that, you need to
create a new object with `<-`. You can call the object whatever you want, but
use a name that is easy to remember:

```{r}
gapminder_gdp <- select(gapminder, year, country, gdpPercap)
```

## About pipes

During data analysis, we often need to perform several intermediate steps. It is
not convenient to save the output of each since you have to think of names for
each output object, and may not even use them for anything later. A better way
to do this is using something called the "pipe". The pipe is written like this:
`|>` (some packages also write it like this: `%>%`).

The pipe takes the output from one function and passes it to the input of the
next function. You can think of it as saying "and then":
  
- Do this **and then** do this, **and then** do this...
- Do this **`|>`** do this, **`|>`** do this...

We can even use the pipe just with one function. Read the following as "start
with `gapminder` **and then** select only year, country, and population":

```{r}
gapminder |> select(year, country, pop)
```

This becomes very useful when we want to do **multiple steps**. Read this as
"start with `gapminder`, **and then** select only year, country, and population,
**and then** arrange by year":

```{r}
gapminder |>
  select(year, country, pop) |>
  arrange(year)
```

We can make it easier to read by putting each step on its own line (the result
is exactly the same, since R ignores spaces and line breaks):

```{r}
gapminder |>
  select(year, country, pop) |>
  arrange(year)
```

Pipes are very useful because you don't have to save each intermediate step.
This is a very useful way to manipulate data. Therefore, the rest of the lesson
will use the pipe, to help you get used to it.

## Subset rows with `filter()`

Use the `filter()` function to only keep rows that **meet a certain condition**.
For example, let's only keep the data in Europe:

```{r}
gapminder |> filter(continent == "Europe")
```

## Modify data with `mutate()`

For example, we could change the units of population to millions of people:

```{r}
gapminder |> mutate(pop = pop / 1000000)
```

If we provide a new column name, that column will be added

```{r}
gapminder |> mutate(pop_mil = pop / 1000000)
```

## Calculate summary statistics with `summarize()`

For example, let's calculate the overall mean population:

```{r}
gapminder |> summarize(mean_pop = mean(pop))
```

As another example, let's calculate the total population over all the data:

```{r}
gapminder |> summarize(total_pop = sum(pop))
```

## Use `group_by()` to do calculations per group

However, it is often more useful to calculate such summary statistics for
**particular groups**. To do this, first specify the groups with `group_by()`:

```{r}
gapminder |> group_by(continent)
```

Next, use `summarize()` to calculate the summary statistic:

```{r}
gapminder |>
  group_by(continent) |>
  summarize(mean_pop = mean(pop))
```

`summarize()` and `mutate()` are related since they both create new columns (or over-write existing ones). You can remember the key difference between them is that `mutate()` **keeps the number of rows the same**, whereas `summarize()` always **decreases the number of rows**.

## Summary

Here is a list of the data-wrangling commands we have learned so far:

- Sort data with `arrange()`
- Narrow down columns with `select()`
- Filter rows with `filter()`
- Modify data with `mutate()`
- Summarize data with `summarize()`
- Group data with `group_by()`

By combining these functions, each of which is fairly simple, with the pipe (`|>`), you can construct sophisticated data analysis pipelines.

## Submitting the homework

Go to Moodle, click on the Day 4 Homework assignment, and click on the link to
accept the assignment. This will create the repo in your GitHub account.

Next, clone the remote repo to your local machine. Then, edit the file
`day_04_homework.R` file in RStudio. Make sure that your code runs without
errors. Once you have done so, commit your changes and push to the remote. Don't
forget to push! If you don't push, your work will not be submitted.

Be sure to do this BY THE DEADLINE, or your work will not be counted.

## Attributions

These materials were modified by Joel H. Nitta from those posted at
https://swcarpentry.github.io/r-novice-gapminder/ and
https://datacarpentry.org/R-ecology-lesson under the [Creative Commons
Attribution (CC BY 4.0) license](https://creativecommons.org/licenses/by/4.0/).
